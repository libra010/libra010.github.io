消息队列实现



## JMS、AMQP 规范

JMS规范和AMQP规范是消息队列的重要标准规范，相应的实现ActiveMQ和RabbitMQ也成为Kafka发布之前消费队列领域经典的开源实现。由于RabbitMQ在吞吐量上更加具有优势，逐渐成为主流。

- JMS规范（面向应用）

  JMS规范是API规范，旨在为Java程序提供API接口。它直接从应用需求出发，将消息的两种基本使用模式——**点对点（Queue）**和**发布/订阅（Topic）**作为两个顶级概念封装起来。

- AMQP规范（面向路由）

  AMQP规范是网络协议规范，定义消息的传输和路由规则。它的设计更像一个网络路由器。它有三个核心组件——**Exchange（交换机）**，**Queue（队列存储）**和**Binding（路由规则）**。

可见，JMS规范面向开发者，提供的Queue语义和Topic语义更为清晰且语义固定。而AMQP规范则更为灵活，它不直接提供Queue和Topic语义，而是交由开发者利用灵活的路由规则去自己实现。

AMQP有四种 Exchange 类型（Direct, Fanout, Topic, Headers）

1. Direct（路由规则：完全匹配 routing key）用于直接**实现Queue语义**。

2. Fanout（路由规则：忽略 routing key，广播到所有绑定的 Queue）用于**实现Topic语义**，消息会重复存储。

3. Topic（路由规则：routing key 与 binding key 模式匹配）多播路由，比Fanout更为细致。

4. Headers（路由规则：基于消息的 headers（键值对），忽略 routing key）针对消息参数进行路由。





## Kafka

Kafka的 Topic 来源于JMS规范，代表了面向主题、解耦的、多对多的消息分发策略，天然支持发布订阅模型。

每个Topic分为多个Partition，Partition 的语义更类似于传统消息队列中的 Queue队列，是一个有序的消息队列，作为实际的消息存储。Topic更类似于消息主题的逻辑概念，真正的消费单元是Partition。

Consumer Group 是Kafka 0.8引入的概念，让多个消费者自动且安全地竞争消费同一个Topic，背后做了自动 Rebalance负载均衡，自动 Partition 分配，保证一个 Partition 只被组内一个消费者消费。Consumer Group的引入，实现了点对点，竞争消费等更为完整的队列语义。

单个Consumer Group属于Queue队列语义，多个Consumer Group属于Topic发布订阅语义。

Kafka的规则：

1. 单个Partition内的消息是严格有序的。
2. 同一个Consumer Group内一个Partition只能有一个消费者消费。（多个Consumer Group不受限制）
3. 同一个Consumer Group内一个消费者可以消费多个Partition。
4. 同一个Consumer Group内消费者数量小于Partition数量会自动Rebalance，大于Partition数量会导致消费者闲置。

> RabbitMQ中可以一个Queue被多个消费者消费，会采用轮询的方式进行消息分发。





传统消息队列（如 RabbitMQ、ActiveMQ）默认支持推模型Push，它们的拉模型Pull需要显式配置并且性能比推模型差，仅用于特殊场景。Kafka仅支持拉模型Pull，不支持推模型Push。

传统消息队列支持消息确认机制ACK，自动确认可能会导致消息丢失，手动确认更加严格并且未收到ACK会将消息Requeue重新入队，无论哪种确认完成后删除消息。Kafka没有传统意义上的 ACK 机制，消费者维护一个offset来定位消费进度，消息不会因为消费后而删除，其他消费组仍可消费并且支持通过重置offset回溯消费。



RocketMQ在核心架构上更加类似Kafka，比如拉模型Pull和offset确认机制，但是也引入了传统消息队列的一些功能，实现了一些传统消息队列的队列语义。










END