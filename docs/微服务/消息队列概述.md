消息队列概述



## 消息传递

**消息传递范式**是计算机系统中的一种核心抽象模型，其核心机制是通过一个中介队列（或通道）来传递消息，从而实现发送方与接收方在时间和空间上的双重解耦：

- 时间解耦：消息可暂存于队列中，发送方与接收方无需同时活跃，天然支持异步通信；
- 空间解耦：双方仅与队列交互，彼此无需知晓对方的存在、位置或实现细节。

消息传递范式在计算机系统中有广泛的实现：

- 操作系统层面，作为进程间通信（IPC）的核心机制之一，例如 POSIX 标准定义的消息队列
- 编程语言层面，部分语言将消息传递作为并发模型的基础，如 Go 语言的 channel。
- 中间件层面，比如RabbitMQ和Kafka，又称面向消息的中间件 Message-oriented middleware (MOM) 。

https://en.wikipedia.org/wiki/Message_queue

https://en.wikipedia.org/wiki/Message-oriented_middleware

https://news.qq.com/rain/a/20241226A057XP00





## 消息队列中间件

消息队列中间件通常支持两种模式：

- 消息队列（点对点）一条消息仅被一个消费者消费，用于任务分发。
- 发布/订阅（Pub/Sub）消息广播给所有订阅者，用于事件通知。

一些消息队列中间件支持的特殊模式：

- 延时消息

  语义：消息在指定时间后才对消费者可见。RabbitMQ插件实现，RocketMQ原生支持。

- 事务消息

  语义：确保本地DB操作和MQ操作的原子性。RocketMQ原生支持。

- 死信队列

  语义：处理失败、过期或被拒绝的消息自动路由到专用队列。RabbitMQ和RocketMQ原生支持。

- 优先级队列

  语义：对队列中的消息进行优先级排序。RabbitMQ原生支持。

> Kafka为了吞吐量性能，只做极简的消息队列功能，上述的一些特殊模式需要靠消费者自行实现。
>





## MQ在分布式系统中的作用

消息队列中间件（MOM）在分布式系统中的主要作用：

- 削峰填谷（流量缓冲）

  在高并发的场景（如秒杀活动、促销高峰），系统瞬时流量可能远超下游服务（如数据库、订单处理服务）的最大处理能力。消息队列可以作为异步缓冲区，接收所有突增的流量消息并将其暂存。达到负载均衡的效果。

- 系统解耦（松耦合）

  在微服务架构中，服务之间的依赖关系复杂。MOM 使得服务间通信转变为与中介队列的交互。生产者只需将消息发送到指定主题或队列，无需关心消费者的地址和实现。可以独立部署与扩展，任何服务可以独立部署或关闭，不影响其他服务的运行。服务可以遵循单一职责，专注自身的逻辑。
  
- 异步通信（提升性能）

  对于一些耗时操作（如发送邮件/短信、积分计算、日志记录），如果同步调用会显著增加用户请求的响应时间。将耗时操作封装成消息，发送给队列，主业务流程立即返回（快速响应用户）。后台服务异步地从队列中取出消息进行处理。极大地提升用户体验（响应更快），并提高系统整体的并发能力。
  
- 事件驱动（数据同步与分发）

  消息队列充当事件总线 (Event Bus)，是实现事件驱动架构（EDA）的基础。当一个核心系统发生状态变更（例如：订单服务“支付成功”），它发布一个事件消息。多个下游服务可以实时且可靠地订阅事件达成系统间地一致性。方便业务扩展，增加新的业务方只需要订阅消息，无需修改上游代码。





## 流式处理Stream

TODO.





## 解决方案

1. **消息传递机制  推模式（Push）和 拉模式（Pull）**

   推模式Push适合实时性要求高和消费者能及时处理的场景，拉模式Pull适合消费者处理能力有限的场景。

   RabbitMQ默认采用Push；Kafka默认采用Pull，RocketMQ默认采用Pull（使用长轮询看起来像Push）。

2. **如何保证消息不丢失**

   三个阶段保证，生产者通过消息确认机制保证消息发送，Broker通过持久化保证消息存储，消费者通过确认ACK保证消息成功消费。

3. **如何处理重复消息**

   因为保证消息不丢失需要重试机制，所以重复消息是不可避免的。只有让消费者的处理逻辑具有幂等性才能保证不处理重复消费，常见的方法有为消息分配独立的消息ID，或者利用业务的幂等性，比如唯一业务主键订单号，或者状态机校验，或者数据库唯一索引，或者类似HTTP PUT方法的天然幂等。

4. **如何保证消息有序性**

   Kafka保证单个Partition内的消息是有序的，可以通过只设置单个Partition和单个生产者单个消费者保证消息的全局有效，但是这样无法利用Kafka的分布式并行性能。Kafka推荐使用Partition Key将一组消息根据业务ID作为Key发送到不同的Partition，来保证单个业务ID的局部有序，而不是全部业务的全局有序。
   RabbitMQ保证单个Queue中的消息是有序的，类似于Kafka也可配置消息分区实现局部有序保证性能。
   RocketMQ原生支持顺序消息API，将一组消息按照消息组（MessageGroup）进行分组，RocketMQ保证同一组内的消息是有序的。

5. **如何处理消息堆积**

   通常是因为消费者消费能力弱，可以优化消费者代码逻辑，或者增加线程提高并行度，或者水平扩展消费者部署多个消费者实例。还有方法是对生产者进行限流（Kafka有配置参数），对消费者进行消费降级（对优先级较低的消息延迟处理或丢弃）。

6. **Requeue和Rebalance是什么意思**

   Requeue（重入队列）指当消费者未能成功处理一条从队列中取出的消息时，将这条消息重新放回队列中，以便稍后可以被其他消费者或它自己再次尝试消费。目的是确保消息不会因为一时的处理失败而丢失。缺点是会导致消息延迟消费或者消息有序性发生变化。注意Kafka不支持Requeue。

   Rebalance（重新平衡）只是消息队列系统（尤其是在像 Kafka 这种基于分区和消费者组（Consumer Group）模型的系统中）中，用于重新分配分区（Partition）和消费者（Consumer）之间的消费对应关系的过程。当新消费者加入消息者组，现有消费者离开消费者组，Topic的分区发生变化的时候，都会触发Rebalance。目的是确保消费者组中的所有分区都能被组内的消费者均匀、高效地消费。缺点是可能导致幂等性和乱序问题。








END