垃圾回收算法



## 引用计数（Reference Counting）

这是第一个垃圾回收算法（虽然在现代GC看来它根本不能称之为GC）。在1959年的LISP语言中首次被使用。

它通过维护每个对象的引用计数来判断该对象是否仍然被使用，优点是实时性的GC，缺点是无法解决循环引用问题。虽然现在被大型生产语言淘汰，但是在Python等语言中仍然得到重要使用。





## 标记-清除算法（Mark-and-Sweep）

标记-清除算法 是1960年提出的一种垃圾回收算法，解决了循环引用问题。该算法分为两部分：**标记（Mark）** 阶段从根对象（例如栈、全局变量等）出发，遍历所有可达对象并将它们标记为存活；**清除（Sweep）** 阶段则扫描整个堆，回收未被标记的对象。

标记-清除算法是现代垃圾回收技术的基石。然而，用户进程在执行过程中会不断改变对象的引用关系，因此，为了保证标记过程的正确性，GC 必须在某个一致的全局快照下工作。为了完成标记阶段，垃圾回收器通常需要暂停用户进程，这一暂停被称为 **Stop-The-World（STW）** 停顿。

在1978年，Dijkstra 等人提出的三色抽象中证明了，在通用编程语言中，完全避免 STW 暂停是不可能的。后续的垃圾回收算法主要致力于减少 STW 停顿的时间，以提升程序的响应性和吞吐量。

后续的现代GC基本都基于此，这类垃圾回收算法区别于引用计数，被称为 **Tracing GC（追踪垃圾回收）**，或者叫**可达性分析算法**，核心思想是从GC Root对象开始搜索所有对象，不可达的对象会被判断为不可用，进行内存回收。





## 复制算法（Copying GC）

复制算法将内存分为两个相同大小的区域，通常称为 From 空间和 To 空间。在垃圾回收时，首先通过类似标记过程的可达性分析，找到所有可达对象，然后将它们从 From 空间复制到 To 空间。完成复制后，From 空间中的内容会被清空，从而自动回收不可达对象。下一次垃圾回收时，From 空间和 To 空间会交换角色。

该算法的优势在于它避免了内存碎片化，并且执行效率较高，因为只需要将存活的对象复制到新的区域，不需要像标记-清除算法那样进行复杂的扫描和整理。然而，复制算法的缺点是需要 两倍的内存空间，因为需要同时维持两个内存区域。此外，对于大对象的复制性能较差，因为它们可能需要占用大量内存空间，复制的开销较大。

复制算法特别适用于对象生命周期较短、且活跃对象相对较少的场景，通常用于 年轻代垃圾回收（如 Java 中的年轻代回收）。在这种情况下，复制算法能够有效减少内存碎片并提高回收效率。





## 分代收集（Generational GC）

1983年，David Ungar 提出了 分代收集（Generational Collection）算法，基于这样的观察：大多数对象的生命周期都非常短暂，因此可以将堆内存划分为多个代（Generation），例如 年轻代 和 老年代。

年轻代（Young Generation）：存储生命周期较短的对象，这些对象大部分在很短时间内会变得不可达。

老年代（Old Generation）：存储生命周期较长的对象，这些对象较少会被垃圾回收。

分代收集的核心思想是：年轻代的对象通常会经历频繁的垃圾回收，因为它们很快就会变得不可达；而老年代的对象较少会发生垃圾回收，因为它们的生命周期较长，且不容易成为垃圾。这样，垃圾回收的频率和开销得到有效的优化。

在分代收集中，年轻代 通常使用 复制算法（例如 Semi-Space GC）进行高效的回收，而 老年代 则采用 标记-清除 或 标记-整理 算法，回收频率较低。通过这种方式，可以显著提高垃圾回收效率，减少停顿时间。

分代回收的优势是将年轻代和老年代的对象使用不同的垃圾回收策略，从而提高效率。JVM虚拟机就支持对年轻代和老年代的对象配置不同的垃圾回收策略。

分代垃圾回收的核心思想已经被广泛采纳，并成为现代编程语言（Java、C#、JavaScript V8等等）垃圾回收策略的标准架构之一。





## 进一步的发展

**增量垃圾回收**：将垃圾回收过程分解成多个小步骤，在程序运行期间逐步进行，而不是一次性进行完整的回收。

**并行垃圾回收**：利用现代多核处理器的优势，让**标记（Mark）**过程与用户线程并发执行，只在开始和结束时短暂 STW（“初始标记”和“重新标记”）。



Go1.5是个里程碑式的版本，对垃圾回收进行了彻底的重构，采用了 并行标记-清除 的方式。





## Java垃圾回收

Java 的垃圾回收器是一整套内存管理策略，不是单一算法。根据老年代和年轻代采用不同的算法。

**Serial GC** 是 JDK 最早的默认垃圾回收器，采用单线程执行，分代回收策略（年轻代使用复制算法，老年代使用标记-整理），因为简单高效，至今仍适用于单核CPU和内存受限应用。

**Parallel GC** 在 JDK 1.4 中引入，目标是最大化应用吞吐量（Throughput），在年轻代和老年代均使用多线程并行回收，JDK 1.6 开始成为默认GC策略。

**CMS GC** 在 Java5 中引入，目的是减少STW停顿时间，适用于响应性要求高（**低延迟**）的场景，在 Java5 到 Java8 中作为一个可选的垃圾回收器。

**G1 GC** 在 Java7 版本中首次引入，目的是解决CMS GC的一些问题，并进一步优化低停顿的场景要求（用于取代CMS GC），逐渐发展成熟，在Java9中取代Parallel GC成为默认的垃圾回收器。

> 默认的 JDK 垃圾回收器一般倾向于保证吞吐量（throughput），从而牺牲延迟性（latency），因为Java用于Web服务端比较广泛。而Java客户端则倾向于延迟性，比如安卓上的JVM。

> Java 的垃圾回收策略是只能选择一种，虽然某些策略内部集成了多种算法，但这是内部实现。比如CMS策略在年轻代使用ParNew，老年代使用CMS。



分代策略

垃圾回收策略内的分代，新生代（分为 Eden 区和 Survivor 区，Survivor 区又能进一步分为From区和To区两个区域），老年代（Old 区）。（Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 再划分为两个区是为了复制GC算法）

大部分情况下，对象分配内存会首先从 Eden 区分配。 Eden 区不足时，会触发一次 **Minor GC**，这个GC会比较频繁，通常能回收绝大部分的对象内存，未回收的进入Survivor From区。Survivor区域不足时也会触发一次 Minor GC。多次Minor GC后仍存在的对象会被晋升到老年区。老年区的垃圾回收被称为 **Major GC**。另外 **Full GC** 指的是对所有分区进行垃圾回收，通常跟 Major GC 是一个意思。





## 其他语言的垃圾回收

目前只有 JVM 支持自选垃圾回收策略，其他语言的垃圾回收只有默认一种。比如Python的引用计数和循环垃圾回收器，Go的并发和三色标记-清除，JS V8 的分代和多种算法协同，.NET仅支持客户端和服务端策略二选一。

Golang，垃圾回收在2015年的Go1.5版本进行了一次完全重构，引入了并发和三色标记，大幅缩短STW时间。

CPython，主要机制是引用计数，辅助机制是基于标记清除的分代循环GC（由gc模块实现，默认启用）。





为什么 Python 工程师很少像 Java 工程师那样讨论垃圾回收？ - RednaxelaFX的回答 - 知乎
https://www.zhihu.com/question/38380754/answer/76278025

各种编程语言的实现都采用了哪些垃圾回收算法？这些算法都有哪些优点和缺点？ - Laruence的回答 - 知乎
https://www.zhihu.com/question/20018826/answer/13705383

主流的垃圾回收机制都有哪些? - 方泽图的回答 - 知乎
https://www.zhihu.com/question/32373436/answer/56384255

java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎
https://www.zhihu.com/question/53613423/answer/135743258

Major GC和Full GC的区别是什么？触发条件呢？ - RednaxelaFX的回答 - 知乎
https://www.zhihu.com/question/41922036/answer/93079526

如何评价《垃圾回收的算法与实现》及其作者中村成洋？ - RednaxelaFX的回答 - 知乎
https://www.zhihu.com/question/39337535/answer/80884071





END